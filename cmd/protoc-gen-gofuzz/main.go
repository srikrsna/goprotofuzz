package main

import (
	"os"
	"path"
	"path/filepath"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	generatedFilenameExtension = ".fuzz.go"
	generatedPackageSuffix     = "fuzz"
	generatedCommonFileName    = "fuzz.fn"

	gofuzzPkg      = protogen.GoImportPath("github.com/google/gofuzz")
	goprotofuzzPkg = protogen.GoImportPath("github.com/srikrsna/goprotofuzz")
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		packages := make(map[string][]*protogen.File)
		for _, file := range plugin.Files {
			if file.Generate {
				packages[file.Proto.GetPackage()] = append(packages[file.Proto.GetPackage()], file)
				genFile(plugin, file)
			}
		}
		for _, p := range packages {
			genPkg(plugin, p)
		}
		return nil
	})
}

func genPkg(plugin *protogen.Plugin, files []*protogen.File) {
	if len(files) == 0 {
		return
	}
	g := plugin.NewGeneratedFile(
		filepath.Join(
			filepath.Dir(files[0].GeneratedFilenamePrefix),
			generatedCommonFileName+".go",
		),
		protogen.GoImportPath(path.Join(
			string(files[0].GoImportPath),
			string(files[0].GoPackageName),
		)),
	)
	genPkgHeader(g, files[0].GoPackageName)
	g.P("func FuzzFuncs() []any {")
	g.P("return ff[:]")
	g.P("}")
	g.P()
	g.P("var ff = [...]any{")
	for _, file := range files {
		for _, message := range file.Messages {
			genPkgMessage(g, message)
		}
		for _, enum := range file.Enums {
			genPkgEnum(g, enum)
		}
	}
	g.P("}")
}

func genPkgEnum(g *protogen.GeneratedFile, enum *protogen.Enum) {
	g.P("Fuzz", enum.GoIdent.GoName, ",")
}

func genPkgMessage(g *protogen.GeneratedFile, message *protogen.Message) {
	g.P("Fuzz", message.GoIdent.GoName, ",")
	for _, message := range message.Messages {
		if message.Desc.IsMapEntry() {
			continue
		}
		genPkgMessage(g, message)
	}
	for _, enum := range message.Enums {
		genPkgEnum(g, enum)
	}
}

func genFile(plugin *protogen.Plugin, file *protogen.File) {
	if len(file.Messages) == 0 && len(file.Enums) == 0 {
		return
	}
	file.GoPackageName += generatedPackageSuffix
	dir := filepath.Dir(file.GeneratedFilenamePrefix)
	base := filepath.Base(file.GeneratedFilenamePrefix)
	file.GeneratedFilenamePrefix = filepath.Join(
		dir,
		string(file.GoPackageName),
		base,
	)
	generatedFile := plugin.NewGeneratedFile(
		file.GeneratedFilenamePrefix+generatedFilenameExtension,
		protogen.GoImportPath(path.Join(
			string(file.GoImportPath),
			string(file.GoPackageName),
		)),
	)
	genFileHeader(generatedFile, file)
	for _, message := range file.Messages {
		genMessage(generatedFile, file, message)
	}
	for _, enum := range file.Enums {
		genEnum(generatedFile, file, enum)
	}
}

func genPkgHeader(g *protogen.GeneratedFile, pkgName protogen.GoPackageName) {
	g.P("// Code generated by ", filepath.Base(os.Args[0]), ". DO NOT EDIT.")
	g.P()
	g.P("package ", pkgName)
	g.P()
}

func genFileHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by ", filepath.Base(os.Args[0]), ". DO NOT EDIT.")
	g.P("//")
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("//", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// Source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
}

func genMessage(g *protogen.GeneratedFile, file *protogen.File, message *protogen.Message) {
	g.P("// Fuzz", message.GoIdent.GoName, " is a fuzz function.")
	g.P("// If can be registered using `Fuzzer.Funcs` function.")
	g.Annotate("Fuzz"+message.GoIdent.GoName, message.Location)
	g.P("func Fuzz", message.GoIdent.GoName, "(x *", message.GoIdent, ",f ", gofuzzPkg.Ident("Continue"), ") {")
	for _, field := range message.Fields {
		if field.Oneof != nil && !field.Desc.HasOptionalKeyword() {
			continue
		}
		switch {
		default:
			g.P("f.Fuzz(&x.", field.GoName, ")")
		}
	}
	for _, oneOf := range message.Oneofs {
		if oneOf.Desc.IsSynthetic() {
			continue
		}
		g.P("switch f.Int31n(", len(oneOf.Fields)+1, ") {")
		for i, field := range oneOf.Fields {
			g.P("case ", i, ":")
			g.P("var o ", field.GoIdent)
			g.P("f.Fuzz(&o.", field.GoName, ")")
			g.P("x.", oneOf.GoName, " = &o")
		}
		g.P("}")
	}
	g.P("}")
	for _, message := range message.Messages {
		if message.Desc.IsMapEntry() {
			continue
		}
		genMessage(g, file, message)
	}
	for _, enum := range message.Enums {
		genEnum(g, file, enum)
	}
}

func genEnum(g *protogen.GeneratedFile, file *protogen.File, enum *protogen.Enum) {
	g.P("// Fuzz", enum.GoIdent.GoName, " is a fuzz function.")
	g.P("// If can be registered using `Fuzzer.Funcs` function.")
	g.Annotate("Fuzz"+enum.GoIdent.GoName, enum.Location)
	g.P("func Fuzz", enum.GoIdent.GoName, "(x *", enum.GoIdent, ",f ", gofuzzPkg.Ident("Continue"), ") {")

	g.P("switch f.Int31n(", len(enum.Values), ") {")
	for i, v := range enum.Values {
		g.P("case ", i, ":")
		g.P("*x = ", v.GoIdent)
	}
	g.P("}")
	g.P("}")
}
